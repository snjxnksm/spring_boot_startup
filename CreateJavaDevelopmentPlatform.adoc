= Spring Bootを導入するときにやったこと
:toc: left
:toc-title: 目次
:auther: 中島慎児
:source-highlighter: coderay

== はじめに（メンバーのレベルなど）

Spring Boot を元にした開発基盤を構築するときに考慮したこと。 +
そして、メンバーの未経験率が高いテクノロジーをスムーズに導入するにはどうするかなどを記述する。 +

Java8で、link:https://projects.spring.io/spring-boot/[Spring Boot]を使ったシステムを構築した際に、実施したこと、気を付けたことなどを共有する。 +
チーム規模は8人程度で、Javaの基本的なスキルは問題なく、ただしフレームワークの Spring Boot はほぼ初めてという状態からのスタート。

== 事前準備編

事前に考慮すべきことは以下のように想定した。

. 実行環境の確認
. 手順書の準備
. 開発環境をそろえる
. ビルドはIDEに依存しないようにする。
. コーディング規約はできるだけ自動で
. パッケージの切り方を決める
. サンプルコードを書く

<<<
=== 実行環境の確認

まず最初に、本番環境で想定される構成を確認する。 +

ポイントは、ネットワークの構成、ファイヤーウォールやロードバランサーの位置、アプリケーションサーバの構成、関連する別サーバや外部サービスの有無、データベースの構成など。 +
特にアプリケーションサーバの構成は必ず確認する。 +

てっきり１台のみとおもいこんで設計を進めると、あとから「いや2台構成で上流にロードバランサーがいるんですよ」などと言われて大慌てすることになる。 +
1台のみで独立している場合と、複数台構成でいつでも切り替えられるようにする場合では、かなりソフトウェアの構造が変わってくる。 +
Webアプリケーションの場合は、複数台構成ではまず、セッションをどこに格納するのかの検討が必要になる。 +
検討結果によって、ネットワーク構成の中にlink:https://redis.io/[Redis]などのKey Value Storeを導入するか、セッションデータを登録するテーブルをデータベースに設けるなどの、作成しようとしているJavaシステム外部での対処が必要になる場合がある。 +
どちらにしても仕組みを後から導入するのはかなり骨が折れる。 +

<<<
=== 手順書の準備

ドキュメント（設計書や開発環境の構築手順書など）はテキストベースにする。理由は、迅速な作成と更新と閲覧のため。 +

ドキュメントは気を付けないと容易に腐る。 +
最終的な納品物は体裁を気にする必要もあるが、チーム内で流通する情報は鮮度が命である。 +
これに対抗するには頻繁な更新しかないが、そのためには更新にかかる手間そのものを下げる必要がある。 +

コツとしては、何かしらドキュメントを作成しなければならない場合に、可能であれば要求される前に作って共有する。 +
まとまった資料として要求されると、かならず資料作成に入る前に資料の見栄えに関する要求が暗黙の裡に入ってくる。たとえばExcelで作ってくれとか。 +
そうなる前に、markdownやasciidocなどの見栄えをある程度コントロールできるテキストファイルでドキュメントを作ってしまうと、意外と受け入れられやすい。 +

<<<
=== 開発環境をそろえる

チームメンバーの開発環境は可能な限りそろえる。 +

メンバー各自にセットアップを任せると、同質の環境が揃わない可能性がある。  +
最終的な成果物はJavaのソースコードなので、それさえ正しく提供できれば良いという考え方もあるが、同質の環境でない場合、不具合の原因追求の際に考慮すべき点が無用に多くなる。 +

開発環境を揃えるために最も有効な手は、扱いやすい構築手順書を作成し開示することである。 +
（業務にかかわる記述を排除した手順書を例として示すと link:https://github.com/snjxnksm/javaenv/blob/master/steps/java_env_install.md[こうなる]。）

<<<
=== スケルトンを作る手順を公開する

モダンなフレームワークにはたいてい、Railsでいうscaffoldのような、最初の一歩を生成する手段がある。 +
Spring Boot でいうなら、link:https://start.spring.io[SPRING INITIALIZR]がある。 +

チームメンバーの理解を促すために、この最初の一歩の手順を公開するといいと思う。 +

<<<
=== ビルドはIDEに依存しないようにする（CIを視野に入れる）

Eclipseなどの高機能なIDEを使えば、コンパイルなどの環境は特に意識しなくても出来上がることが多い。 +
開発作業中はそれでまったく問題ないが、IDEに依存しないビルド方法を検討する必要がある。 +

ビルドやテストができる環境は、必ずチームメンバ各自の開発環境とは別にひとつ用意する。 +
Jenkinsなどの自動ビルド環境を用意し、チームメンバのマシンの環境とは関係なくビルドできる状態にする。 +
そうすることで、チームメンバの作業状態と関係なく、実行ファイルの作成が可能となる。 +

<<<
=== コーディング規約は、できるだけ自動で

コーディング規約は、静的チェックができる仕組みを整える。 +
チーム内でコードレビューを行うときなどに、改行やインデントの有無などで時間を費やすべきではない。 +
機械にできることは機械にやらせること。 +

そうすれば、コードレビューにおいて、より本質的な内容に集中できる。 +

<<<
=== パッケージの切り方を決める

パッケージの切り方、機能の分解の仕方は事前に検討しておく。 +

詳細なことまで拘束する必要はないが、大雑把な部分は決めておくべき。 +
MVCモデルにおいて、ビジネスロジックをどこにおくか、共有すべきモジュールをどこにおくかなど、チーム内で了解をとる。 +

=== サンプルコードを書く（ことで、フレームワークを先行して理解する）

事前にサンプルコードを書くことで、チームメンバの理解をうながす。 +
同時に、自身の理解も深める。 +

最低限の動くコードを事前に準備することで、チームメンバの参入障壁を可能な限り下げることができる。 +
チームメンバにはフレームワークを使用するにあたって当然のごとく自主学習が暗黙のうちに要求されるが、最初の一歩に当たる部分を用意することで、手が出しやすくなる。 +

また、本格的な開発基盤を作る前に、小手調べ的にサンプルコードを書くことで、開発基盤を作る際に考慮すべき点を洗い出すことができる。 +

<<<
== 開発基盤構築編

開発基盤を構築する際の考慮すべき点は以下の通り。 +

. lombokを使う
. 現在日時は１箇所に集める
. local,develop,production環境きりわけ
. ログ出力
. 親クラスを作る
. 排他制御を作る
. 認証
. 監査証跡

<<<
=== lombokを使う

いわゆるボイラープレートコードを自動生成させるため、プロジェクトには最初からlombokを導入する。 +
link:https://projectlombok.org/[Project lombok] +

lombokを導入するとしないとでは、コード記述量が段違いに違う。 +
lombokを導入することで、初期化のコードやSetter/Getterを動的に自動作成させることができる。 +

<<<
=== 現在日時は１箇所に集める

現在日時を取得する場合は、一か所に集めること。 +
ユーティリティクラスを設けて現在時刻を取得するメソッドを作成し、各所で使用するようにアナウンスする。 +
または、親クラスにて自動的にそのメソッドを呼ぶようにする。 +
そうすることで、実行順による時刻の不整合の防止や、単体テスト時の時刻のすり合わせなどに対応しやすくする。 +

<<<
=== local,develop,production環境きりわけ

プロジェクト作成時に、チームメンバの実行環境と、開発サーバ向けの環境、本番サーバ向けの環境でそれぞれの設定を個別に記述できるようにしておく。 +
実行環境の変更を頻繁に実行せずに済むようにするべき。 +

<<<
=== ログ出力

ログ出力も同様に、環境の切り分けと共通の出力方法で記述できるように、プロジェクト作成時に用意しておく。 +

<<<
=== 親クラスを作る

フレームワークで使用する基本的なモデルのそれぞれに、当該プロジェクトで使用する親クラスを用意しておく。 +
spring bootに関していえば、コントローラ、サービス、モデルそれぞれに用意するとよいと思われる。 +

<<<
=== 排他制御を作る

データベースの排他制御（悲観的ロック、楽観的ロック）は、プロジェクト共通の書き方をプロジェクト開始時点で決めておく。 +
モデルやコントローラの親クラスで作りこんでおくとなおいい。 +

<<<
=== 認証

同様に、認証に関してもプロジェクトの初期段階で基本的な書き方を作成してアナウンスすること。 +
コントローラの親クラスにて作りこんでおくとなお良し。 +

<<<
=== 監査証跡

データベースの設計上、各テーブルを誰がいつ作ったかなどの情報を持たせることは頻繁に要求される。 +
だいたいは、作成時のログインユーザ、作成日時、更新時のログインユーザ、更新日時などをすべてのテーブルで項目として持つことになる。 +
こちらも、モデルの親クラスで作りこんでおくこと。 +
